import krit;
import krit.**;
import krit.backend.**;

using rules KritUtils;

var bunnies: Int = 0;
var asset: Ptr[ImageData] = null;

function rotateImage(e: Ptr[Entity], context: Ptr[UpdateContext]) {
    var img: Ptr[Image] = e.userData;
    img.angle += context.elapsed * PI / 8;
    img.scale.scale += context.elapsed;
    while img.scale.scale > 1.5 {
        --img.scale.scale;
    }
    img.alpha += context.elapsed / 1.25;
    img.alpha = img.alpha % 1;
}

function scrollUp(action: &ActionContext, update: &UpdateContext) {scroll(update, 0, -1);}
function scrollDown(action: &ActionContext, update: &UpdateContext) {scroll(update, 0, 1);}
function scrollLeft(action: &ActionContext, update: &UpdateContext) {scroll(update, -1, 0);}
function scrollRight(action: &ActionContext, update: &UpdateContext) {scroll(update, 1, 0);}
function scroll(update: &UpdateContext, x: Int, y: Int) {
    update.scene.camera.position.x += update.elapsed * 64 * x;
    update.scene.camera.position.y += update.elapsed * 64 * y;
}

function mousePos(action: &ActionContext, update: &UpdateContext) {
    printf("%i,%i\n", action.level.position.x, action.level.position.y);
}

function addBunnies(action: &ActionContext, update: &UpdateContext) {
    spawnBunnies(update.scene, 250);
}

function spawnBunnies(scene: Ptr[Scene], n: Int) {
    bunnies += n;
    printf("bunnies: %i\n", bunnies);
    if asset == null {
        var cache = AssetCache.new();
        var context = AssetContext.new(cache);
        asset = context.getImage("wabbit.png");
    }
    var entityPool: PoolAllocator[Entity] = PoolAllocator[Entity].new(n);
    var imagePool: PoolAllocator[Image] = PoolAllocator[Image].new(n);
    for i in 0 ... n {
        var image: Ptr[Image] = imagePool.alloc(1).unwrap();
        (*image) = struct Image {region: ImageRegion.fromImage(asset)};
        image.centerOrigin();
        image.angle = PI * 2 * random();
        image.position.setTo(-128 + (640 + 256) * random(), -128 + (480 + 256) * random());
        image.scale.scale = 0.5 + random();
        image.alpha = random() as Float;
        image.color = Color.fromRgb(random(), random(), random());

        var entity: Ptr[Entity] = entityPool.alloc(1).unwrap();
        (*entity) = struct Entity;
        entity.position.translate(64, 64);
        var box = image as Box[Graphic];
        entity.graphic = Some(box);
        entity.userData = image;
        entity.onUpdate = rotateImage;

        scene.entities.push(entity);
    }
}

function drawLine(c: &RenderContext) {
    var d = struct DrawContext {context: c, lineThickness: 20, color: 0xff0000, alpha: 0.5};
    d.line(P(0, 0), P(128, 64));
    d.line(P(128, 64), P(256, 0));
    d.rectFilled(R(256, 256, 64, 64));
    d.setColor(0x0000ff, 0.5);
    d.rect(R(256, 256, 64, 64));
    d.circle(P(128, 128), 32, 32);
    d.circleFilled(P(128, 256), 32, 32);
    d.arc(P(192, 64), 32, 0, PI*1.5, 32);
}

function main() {
    var options = struct KritOptions;
    options
        .setTitle("Krit - bunnymark")
        .setSize(640, 360)
        .setFrameRate(60, true);

    var app: Krit;
    app.init(options);

    var scene = Scene.new();
    scene.camera.scaleMode = DefaultStretchScaleMode;
    scene.camera.dimensions.setTo(1920, 1080);
    scene.bgColor = 0x00d4aa;
    app.engine.pushScene(scene);

    var n = 250;
    spawnBunnies(scene, n);

    scene.input.key.define(Key.Left, "scroll_left");
    scene.input.key.define(Key.Right, "scroll_right");
    scene.input.key.define(Key.Up, "scroll_up");
    scene.input.key.define(Key.Down, "scroll_down");
    scene.input.key.define(Key.A, "scroll_left");
    scene.input.key.define(Key.D, "scroll_right");
    scene.input.key.define(Key.W, "scroll_up");
    scene.input.key.define(Key.S, "scroll_down");

    scene.input.mouse.define(Mouse.MouseLeftButton, "click");

    scene.input.on("scroll_left", scrollLeft);
    scene.input.on("scroll_right", scrollRight);
    scene.input.on("scroll_up", scrollUp);
    scene.input.on("scroll_down", scrollDown);
    scene.input.onStart("click", addBunnies);

    var font = BitmapFont.load("test-project/assets/fonts/coiny.84.fnt");

    app.engine.postRender = drawLine;

    app.run();
}
