struct Scene {
    public var bgColor: Color = Color.Black;
    public var bgAlpha: Float = 1;
    public var camera: Camera = struct Camera;
    public var shader: Ptr[SceneShader] = null;

    public var onUpdate: Signal1[Ptr[UpdateContext]] = null;
    public var postUpdate: Signal1[Ptr[UpdateContext]] = null;
    public var onRender: Signal1[Ptr[RenderContext]] = null;
    public var postRender: Signal1[Ptr[RenderContext]] = null;

    public var graphics: Vector[Box[Graphic]] = Vector.new(0x100);
    public var userData: Ptr[Void] = null;

    // scene-specific context
    public var input: InputContext = struct InputContext;
    public var asset: AssetContext = struct AssetContext;

    var allocator: Box[Allocator];

    public static function new(allocator: Box[Allocator]): Self using implicit allocator {
        return struct Scene {
            allocator,
        };
    }

    public function destroy() using implicit this.allocator {
        this.graphics.free();
    }

    public function update(context: Ptr[UpdateContext]) using implicit context {
        this.input.update(context);
        this.camera.update(context);
        this.onUpdate.invoke();
        for g in this.graphics {
            g.update();
        }
        this.postUpdate.invoke();
    }

    public function render(context: Ptr[RenderContext]) {
        if this.bgAlpha > 0 {
            var key = struct DrawKey;
            context.renderSystem.addRect(key,
                struct Rectangle[Int] {
                    point: struct Point[Int],
                    dimensions: struct Dimensions[Int] {x: context.window.width, y: context.window.height},
                },
                struct Matrix,
                this.bgColor.withAlpha(this.bgAlpha), false
            );
        }
        context.camera = this.camera;
        this.onRender.invoke(context);
        for g in this.graphics {
            var render = context.copy();
            g.render(render);
        }
        this.postRender.invoke(context);
    }
}
