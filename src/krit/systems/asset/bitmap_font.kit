import kit.sys.file;

include "expat.h" => "expat";

struct GlyphData {
    public var page: Int = 0;
    public var glyph: CString = null;
    public var rect: Rectangle;
    public var offset: Point[Int];
    public var xAdvance: Int;
}

struct BitmapFont {
    public static const TYPE = "bmfont";

    public var size: Int;
    public var lineHeight: Int;
    public var pages: Vector[ImageRegion];
    public var glyphData: Map[CString, GlyphData];
    public var allocator: Box[Allocator];

    public static function load(allocator: Box[Allocator], path: CString): Shared[Void]
    using implicit allocator {
        var shared = Shared[BitmapFont].alloc(sizeof BitmapFont);
        (*shared) = struct BitmapFont {
            pages: Vector[ImageRegion].new(4),
            glyphData: Map[CString, GlyphData].new(256),
            allocator
        };
        var userData: Ptr[BitmapFont] = shared;
        // font
        //   info: size
        //   common: lineheight
        //   pages
        //     page: file, id
        //   chars (+count)
        //     char: x, y, width, height, xoffset, yoffset, xadvance, page
        var parser: XML_Parser = XML_ParserCreate(null);
        XML_SetUserData(parser, userData);
        XML_SetElementHandler(parser, Self.startElement, null);
        var buf: CArray[Char, 1024];
        var fp = File.read(path);
        do {
            var readLength = fp.readBytes(buf, 1024);
            if readLength == 0 {
                break;
            }
            if XML_Parse(parser, buf, readLength, if readLength < 1024 then 1 else 0) == XML_STATUS_ERROR {
                panic("fail!");
            }
        } while true;
        XML_ParserFree(parser);
        return shared as Shared[Void];
    }

    public static function dispose(allocator: Box[Allocator], font: Ptr[Void]) {}

    static function startElement(userData: Ptr[Void], name: Ptr[Const[Char]], attrs: Ptr[Ptr[Const[Char]]]): Void {
        var font: Ptr[BitmapFont] = userData;
        match name {
            "info" => {
                var attr = attrs;
                while *attr != null {
                    if *(attr + 1) != null {
                        var key = *attr;
                        var value = *(attr + 1);
                        match key {
                            "size" => {
                                font.size = atoi(value);
                            }
                        }
                    }
                    attr = attr + 2;
                }
            }
            "common" => {
                var attr = attrs;
                while *attr != null {
                    if *(attr + 1) != null {
                        var key = *attr;
                        var value = *(attr + 1);
                        match key {
                            "size" => {
                                font.size = atoi(value);
                            }
                        }
                    }
                    attr = attr + 2;
                }
            }
            "page" => {
                var attr = attrs;
                while *attr != null {
                    if *(attr + 1) != null {
                        var key = *attr;
                        var value = *(attr + 1);
                        match key {
                            "file" => {
                                using implicit font.allocator {
                                    printf("loading image %s\n", value);
                                    var asset = ImageLoader.load(value);
                                    font.pages.push(ImageRegion.fromImage(asset));
                                }
                            }
                        }
                    }
                    attr = attr + 2;
                }
            }
            "char" => {
                var glyphData = struct GlyphData;
                var attr = attrs;
                while *attr != null {
                    if *(attr + 1) != null {
                        var key = *attr;
                        var value = *(attr + 1);
                        match key {
                            "x" => {
                                glyphData.rect.x = atoi(value);
                            }
                            "y" => {
                                glyphData.rect.y = atoi(value);
                            }
                            "width" => {
                                glyphData.rect.width = atoi(value);
                            }
                            "height" => {
                                glyphData.rect.height = atoi(value);

                            }
                            "xoffset" => {
                                glyphData.offset.x = atoi(value);

                            }
                            "yoffset" => {
                                glyphData.offset.y = atoi(value);
                            }
                            "xadvance" => {
                                glyphData.xAdvance = atoi(value);
                            }
                            "page" => {
                                glyphData.rect.x = atoi(value);
                            }
                            "letter" => {
                                using implicit font.allocator {
                                    glyphData.glyph = (value as CString).copy();
                                }
                            }
                        }
                        if glyphData.glyph != null {
                            font.glyphData.put(glyphData.glyph, glyphData);
                        }
                    }
                    attr = attr + 2;
                }
            }
        }
    }
}
