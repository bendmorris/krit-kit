struct Camera {
    public var position: Point = struct Point;
    public var dimensions: Dimensions = struct Dimensions;
    public var scaleMode: Box[CameraScaleMode] = empty;
    public var scale: ScaleFactor = struct ScaleFactor;
    public var pixelSnapping: Bool = false;

    public function transformPoint(p: Ptr[Point]): Ptr[Point] {
        return p.subtract(this.position)
            .scale2(this.scale.fullScaleX, this.scale.fullScaleY);
    }

    public function scaleDimensions(d: Ptr[Dimensions]): Ptr[Dimensions] {
        d.setTo(d.width * this.scale.fullScaleX, d.height * this.scale.fullScaleY);
        return d;
    }

    public function transformMatrix(m: Ptr[Matrix]): Ptr[Matrix] {
        m.translate(-this.position.x, -this.position.y)
            .scale(this.scale.fullScaleX, this.scale.fullScaleY);
        return m;
    }

    public function update(update: Ptr[UpdateContext]) {
        if this.dimensions.width == 0 && this.dimensions.height == 0 {
            this.dimensions.setTo(update.window.width, update.window.height);
        }
        if this.scaleMode as Ptr[Void] != null {
            this.scaleMode.updateScale(this, update.window);
        } else {
            this.dimensions.setTo(update.window.width, update.window.height);
        }
    }

    rules {
        ($this.x) => $this.position.x;
        ($this.y) => $this.position.y;
        ($this.width) => $this.dimensions.x;
        ($this.height) => $this.dimensions.y;
    }
}

trait CameraScaleMode {
    function updateScale(camera: Ptr[Camera], window: Ptr[Window]): Void;
}

enum CameraType {
    DefaultStretchScaleMode;
}

implement CameraScaleMode for CameraType {
    public function updateScale(camera: Ptr[Camera], window: Ptr[Window]) {
        camera.scale = struct ScaleFactor {
            scaleX: window.width / camera.dimensions.width,
            scaleY: window.height / camera.dimensions.height,
        };
    }
}
