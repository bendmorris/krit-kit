struct Camera {
    public var position: Point = struct Point;
    public var dimensions: Dimensions = struct Dimensions;
    public var scaleMode: Box[CameraScaleMode] = empty;
    public var scale: ScaleFactor = struct ScaleFactor;
    public var pixelSnapping: Bool = false;

    public function transformPoint(transform: Ptr[RenderTransform], p: Ptr[Point]): Ptr[Point] {
        var position = this.position.copy();
        if transform != null {
            position.scale2(transform.scroll.x, transform.scroll.y);
        }
        return p.subtract(position)
            .scale2(this.scale.fullScaleX, this.scale.fullScaleY);
    }

    public function untransformPoint(transform: Ptr[RenderTransform], p: Ptr[Point]): Ptr[Point] {
        var position = this.position.copy();
        if transform != null {
            position.scale2(transform.scroll.x, transform.scroll.y);
        }
        return p.scale2(1 / this.scale.fullScaleX, 1 / this.scale.fullScaleY)
            .add(position);
    }

    public function scaleDimensions(transform: Ptr[RenderTransform], d: Ptr[Dimensions]): Ptr[Dimensions] {
        return d.setTo(d.width * this.scale.fullScaleX, d.height * this.scale.fullScaleY)
            as Ptr[Dimensions]; // kit #92
    }

    public function unscaleDimensions(transform: Ptr[RenderTransform], d: Ptr[Dimensions]): Ptr[Dimensions] {
        return d.setTo(d.width / this.scale.fullScaleX, d.height / this.scale.fullScaleY)
            as Ptr[Dimensions]; // kit #92
    }

    public function transformMatrix(transform: Ptr[RenderTransform], m: Ptr[Matrix]): Ptr[Matrix] {
        var position = this.position.copy();
        if transform != null {
            position.scale2(transform.scroll.x, transform.scroll.y);
        }
        return m.translate(-position.x, -position.y)
            .scale(this.scale.fullScaleX, this.scale.fullScaleY);
    }

    public function untransformMatrix(transform: Ptr[RenderTransform], m: Ptr[Matrix]): Ptr[Matrix] {
        var position = this.position.copy();
        if transform != null {
            position.scale2(transform.scroll.x, transform.scroll.y);
        }
        return m.scale(1 / this.scale.fullScaleX, 1 / this.scale.fullScaleY)
            .translate(position.x, position.y);
    }

    public function update(update: Ptr[UpdateContext]) {
        if this.dimensions.width == 0 && this.dimensions.height == 0 {
            this.dimensions.setTo(update.window.width, update.window.height);
        }
        if this.scaleMode as Ptr[Void] != null {
            this.scaleMode.updateScale(this, update.window);
        } else {
            this.dimensions.setTo(update.window.width, update.window.height);
        }
    }

    rules {
        ($this.x) => $this.position.x;
        ($this.y) => $this.position.y;
        ($this.width) => $this.dimensions.x;
        ($this.height) => $this.dimensions.y;
    }
}

trait CameraScaleMode {
    function updateScale(camera: Ptr[Camera], window: Ptr[Window]): Void;
}

enum CameraType {
    DefaultStretchScaleMode;
}

implement CameraScaleMode for CameraType {
    public function updateScale(camera: Ptr[Camera], window: Ptr[Window]) {
        camera.scale = struct ScaleFactor {
            scaleX: window.width / camera.dimensions.width,
            scaleY: window.height / camera.dimensions.height,
        };
    }
}
