enum ChildrenMode {
    InlineChildren(horizontal: Bool);
    AbsoluteChildren;
}

struct LayoutGroup {
    var parent: Ptr[LayoutGroup];
    var children: Option[Vector[Ptr[LayoutGroup]]] = None;
    var childrenMode = AbsoluteChildren;

    var padding: CArray[Measurement, 4];
    var measureX: AnchoredMeasurement;
    var measureY: AnchoredMeasurement;
    var width: Measurement = Percent(100);
    var height: Measurement = Percent(100);
    var spacing: Measurement;

    var computed: Rectangle = R(0, 0, 0, 0);

    /**
     * Callback triggered when this element is layed out. For inline children,
     * this callback can modify computed.width and computed.height.
     */
    var onReflow: function (Ptr[LayoutGroup]) -> Void = null;

    rules {
        ($this.left = $value) => $this.setX($value, 0);
        ($this.right = $value) => $this.setX($value, 1);
        ($this.centerX = $value) => $this.setX($value, 0.5);
        ($this.top = $value) => $this.setY($value, 0);
        ($this.bottom = $value) => $this.setY($value, 1);
        ($this.centerY = $value) => $this.setY($value, 0.5);

        ($this.paddingTop) => $this.padding[0];
        ($this.paddingBottom) => $this.padding[1];
        ($this.paddingLeft) => $this.padding[2];
        ($this.paddingRight) => $this.padding[3];
    }

    function inlineChildren(horizontal: Bool = true): Ptr[Self] {
        this.childrenMode = InlineChildren(horizontal);
        return this;
    }

    function setX(v: Measurement, anchor: Float): Ptr[Self] {
        this.measureX.value = v;
        this.measureX.anchor = anchor;
        return this;
    }

    function setY(v: Measurement, anchor: Float): Ptr[Self] {
        this.measureY.value = v;
        this.measureY.anchor = anchor;
        return this;
    }

    function addChild(c: Ptr[LayoutGroup]): Ptr[Self] {
        var children: Ptr[Vector[Ptr[LayoutGroup]]] = null;
        match this.children {
            Some(c) => children = c;
            None => {
                this.children = Some(Vector.new());
                children = this.children.Some.value;
            }
        }
        children.push(c);
        return this;
    }

    function reflow(x: Float, y: Float, availableWidth: Float, availableHeight: Float) {
        availableWidth = this.width.measure(availableWidth);
        availableHeight = this.height.measure(availableHeight);

        var paddingTop = this.paddingTop.measure(availableHeight);
        var paddingBottom = this.paddingBottom.measure(availableHeight);
        var paddingLeft = this.paddingLeft.measure(availableWidth);
        var paddingRight = this.paddingRight.measure(availableWidth);

        var paddedHeight = availableHeight - paddingTop - paddingBottom;
        var paddedWidth = availableWidth - paddingLeft - paddingRight;

        match this.children {
            Some(c) => {
                match this.childrenMode {
                    InlineChildren(horizontal) => {
                        var cursorX: Float = x + paddingLeft;
                        var cursorY: Float = y + paddingTop;
                        var totalWidth: Float = 0;
                        var totalHeight: Float = 0;
                        var first = true;
                        var spacing = this.spacing.measure(if horizontal then paddedWidth else paddedHeight);
                        for child in c {
                            if !first {
                                if horizontal {
                                    cursorX += spacing;
                                    totalWidth += spacing;
                                } else {
                                    cursorY += spacing;
                                    totalHeight += spacing;
                                }
                            }
                            child.reflow(cursorX, cursorY, paddedWidth, paddedHeight);
                            if horizontal {
                                cursorX += child.computed.width;
                                totalWidth += child.computed.width;
                                totalHeight = max(totalHeight, child.computed.height);
                            } else {
                                cursorY += child.computed.height;
                                totalHeight += child.computed.height;
                                totalWidth = max(totalWidth, child.computed.width);
                            }
                            first = false;
                        }

                        this.computed.x = x;
                        this.computed.y = y;
                        this.computed.width = totalWidth + paddingLeft + paddingRight;
                        this.computed.height = totalHeight + paddingTop + paddingBottom;
                    }
                    default => {
                        for child in c {
                            child.reflow(x + paddingLeft, y + paddingTop, paddedWidth, paddedHeight);
                            child.computed.x = child.measureX.measure(paddedWidth, child.computed.width);
                            child.computed.y = child.measureY.measure(paddedHeight, child.computed.height);
                        }

                        this.computed.x = x;
                        this.computed.y = y;
                        this.computed.width = availableWidth;
                        this.computed.height = availableHeight;
                    }
                }
            }
            default => {
                this.computed.x = x;
                this.computed.y = y;
                this.computed.width = availableWidth;
                this.computed.height = availableHeight;
            }
        }

        if this.onReflow != null {
            this.onReflow(this);
        }
    }
}
