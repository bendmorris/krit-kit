struct Engine {
    public var paused: Bool = false;
    public var fps: Int;
    public var fixedFrameRate: Bool;

    public var onUpdate: Signal = null;
    public var postUpdate: Signal = null;

    public var onRender: Signal1[Ptr[RenderContext]] = null;
    public var postRender: Signal1[Ptr[RenderContext]] = null;

    public var userData: Ptr[Void] = null;

    // global context
    public var input: InputContext = struct InputContext;
    public var asset: AssetContext = struct AssetContext;

    var scenes: Vector[Ptr[Scene]] = Vector.new(8);

    public function update(context: Ptr[UpdateContext]) {
        if this.paused {
            return;
        }
        this.input.update(context);
        var childContext = context.copy();
        for scene in this.scenes {
            childContext.scene = scene;
            childContext.asset = scene.asset;
            scene.update(childContext);
        }
    }

    public function render(context: Ptr[RenderContext]) using implicit context {
        var renderer = context.renderer;
        renderer.startFrame();
        renderer.startScene(null);
        this.onRender.invoke();
        renderer.flushScene(null);
        for scene in this.scenes {
            renderer.startScene(scene);
            scene.render();
            renderer.flushScene(scene);
        }
        renderer.flushScene(null);
        this.postRender.invoke();
        renderer.flushScene(null);
        renderer.flushFrame();
    }

    public function pushScene(scene: Ptr[Scene]) {
        this.scenes.push(scene);
    }

    public function popScene() {
        this.scenes.pop();
    }

    public function getActiveScenes(): Slice[Ptr[Scene]] {
        return struct Slice {length: 1, data: &this.scene};
    }

    rules {
        ($this.scene) => $this.scenes.unsafeLast;
    }
}
