struct Engine {
    public static function new(fps: Int, fixedFrameRate: Bool): Engine {
        var scenes = Vector.new(8);
        return struct Engine {
            scenes,
            fps,
            fixedFrameRate
        };
    }

    public var paused: Bool = false;
    public var fps: Int;
    public var fixedFrameRate: Bool;

    public var onUpdate: Signal = null;
    public var postUpdate: Signal = null;

    public var onRender: Signal1[Ptr[RenderContext]] = null;
    public var postRender: Signal1[Ptr[RenderContext]] = null;

    // global context
    public var input: InputContext;
    // public var assetCache:

    var scenes: Vector[Ptr[Scene]];

    public function update(context: Ptr[UpdateContext]) {
        if this.paused {
            return;
        }
        this.input.update(context);
        var childContext = context.copy();
        for scene in this.scenes {
            childContext.scene = scene;
            scene.update(childContext);
        }
    }

    public function render(context: Ptr[RenderContext]) using implicit context {
        var renderer = context.renderer;
        this.onRender.invoke();
        renderer.startFrame();
        for scene in this.scenes {
            renderer.startScene(scene);
            scene.render();
            renderer.flushScene(scene);
        }
        renderer.flushFrame();
        this.postRender.invoke();
    }

    public function pushScene(scene: Ptr[Scene]) {
        this.scenes.push(scene);
    }

    public function popScene() {
        this.scenes.pop();
    }

    rules {
        ($this.scene) => $this.scenes.unsafeLast;
    }
}
